<!doctype html>
<html lang="zh-CN">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>ç›¸ä¼¼æ±‰å­—æ£€ç´¢</title>
  <link rel="stylesheet" href="/ui/style.css" />
  <style>
    /* Use system/browser fonts to render glyphs; no server SVGs */
    .thumb { display:flex; align-items:center; justify-content:center; background:#fff; }
    .thumb .glyph { font-size: 72px; line-height: 1; }
    /* Reasonable CJK/system font stack */
    .glyph, .char { font-family:
      system-ui, -apple-system, Segoe UI, Roboto, Noto Sans, Noto Sans CJK SC,
      Noto Serif CJK SC, PingFang SC, Microsoft YaHei, Hiragino Sans GB,
      Source Han Serif SC, Source Han Sans SC, SimSun, SimHei, serif;
    }
  .badge.warn { background: #fff3cd; color: #8a6d3b; border: 1px solid #f0e1a6; }
  </style>
</head>
<body>
  <div class="page">
    <header class="hero">
      <div class="hero__inner container">
        <div class="brand">ç›¸ä¼¼æ±‰å­—æ£€ç´¢</div>
        <form id="searchForm" class="search">
          <div class="search__group">
            <div class="input-wrap">
              <span class="input-icon">ğŸ”</span>
              <input id="query" type="text" placeholder="æœç´¢æ±‰å­—æˆ– Unicodeï¼ˆè¡Œ / U+884C / 884Cï¼‰" maxlength="10" required />
            </div>
            <div class="input-compact">
              <label for="topk">TopK</label>
              <input id="topk" type="number" min="1" max="50" value="12" />
            </div>
            <button class="btn btn-primary" type="submit">æŸ¥è¯¢</button>
          </div>
          <div id="status" class="status"></div>
        </form>
      </div>
    </header>

  <main class="container wide">
      <section class="panel" id="resultsPanel" hidden>
        <div class="panel__head">
          <div class="panel__title">æœç´¢ç»“æœ</div>
          <div class="panel__meta" id="queryPreview"></div>
        </div>
        <div id="results" class="grid"></div>
      </section>
    </main>

    <footer class="footer">
      <div class="container muted">å›¾ç‰‡æ¥è‡ª /imagesï¼›æ¥å£ /search/char ä¸ /search/unicode</div>
    </footer>
  </div>

  <script>
    const $form = document.getElementById('searchForm');
    const $q = document.getElementById('query');
    const $k = document.getElementById('topk');
    const $res = document.getElementById('results');
    const $status = document.getElementById('status');
    const $preview = document.getElementById('queryPreview');

  function charFromHex(hex){
      try { return String.fromCodePoint(parseInt(hex, 16)); } catch { return '?'; }
    }
  function imgUrlFromHex(hex){ return `/glyph/svg/${hex}`; }
  const FONT_STACK = "system-ui, -apple-system, Segoe UI, Roboto, Noto Sans, Noto Sans CJK SC, Noto Serif CJK SC, PingFang SC, Microsoft YaHei, Hiragino Sans GB, Source Han Serif SC, Source Han Sans SC, SimSun, SimHei, serif";
  const glyphDetector = (() => {
    const canvas = document.createElement('canvas');
    canvas.width = 64; canvas.height = 64;
    const ctx = canvas.getContext('2d');
    function sig(ch){
      ctx.clearRect(0,0,64,64);
      ctx.fillStyle = '#fff';
      ctx.fillRect(0,0,64,64);
      ctx.fillStyle = '#000';
      ctx.textBaseline = 'top';
      ctx.font = '48px ' + FONT_STACK;
      try { ctx.fillText(ch, 0, 0); } catch {}
      const data = ctx.getImageData(0,0,64,64).data;
      let s = 2166136261 >>> 0; // FNV-like
      for(let i=0; i<data.length; i+=16){ s ^= data[i]; s = (s * 16777619) >>> 0; }
      return s >>> 0;
    }
    let tofuSig = null;
    return {
      canRender(ch){
        if(!ch || ch.length === 0) return false;
        try {
          if(tofuSig == null) tofuSig = sig('\uFFFD');
          return sig(ch) !== tofuSig;
        } catch { return true; }
      }
    };
  })();
    function toHex(v){ return String(v||'').toUpperCase().replace(/^U\+/,''); }
    function toSimPercent(distance){
      if(typeof distance !== 'number') return '';
      const p = Math.max(0, Math.min(1, 1 - distance));
      return (p*100).toFixed(1) + '%';
    }
    function copy(text){
      navigator.clipboard?.writeText(text).catch(()=>{});
    }

    function render(items, query, qHex){
      $res.innerHTML = '';
      $preview.innerHTML = query ? `<span class="glyph">${query}</span>` : '';
      const hexQuery = qHex || (query && query.length===1 ? query.codePointAt(0).toString(16).toUpperCase().padStart(4,'0') : null);
      let usedServerSVG = false;

      // Prepend the searched character as the first highlighted card
      if(hexQuery){
        const qUnicode = 'U+' + hexQuery;
        const qChar = query && query.length===1 ? query : charFromHex(hexQuery);
        const qCard = document.createElement('div');
        qCard.className = 'card query';
        qCard.innerHTML = `
          <div class="thumb"></div>
          <div class="code-line">
            <div class="char">${qChar||'?'}<span class="muted sm">${qUnicode}</span></div>
            <span class="badge">æŸ¥è¯¢å­—</span>
          </div>
          <div class="muted sm">è¿™æ˜¯æŸ¥è¯¢çš„å­—</div>
        `;
        $res.appendChild(qCard);
        const t = qCard.querySelector('.thumb');
        if(glyphDetector.canRender(qChar)){
          t.innerHTML = `<div class="glyph" aria-hidden="true">${qChar||'?'}</div>`;
        }else{
          const url = imgUrlFromHex(hexQuery);
          t.innerHTML = `<img src="${url}" alt="${qChar||'?'}" />`;
          const codeLine = qCard.querySelector('.code-line');
          codeLine.insertAdjacentHTML('beforeend', `<span class="badge warn" title="æµè§ˆå™¨æ— æ³•æ¸²æŸ“ï¼Œä½¿ç”¨æœåŠ¡ç«¯SVG">æœåŠ¡ç«¯æ¸²æŸ“</span>`);
          usedServerSVG = true;
        }
      }

      const list = (items||[]).filter(it => !hexQuery || toHex(it.unicode) !== hexQuery);
      if(list.length === 0){
        $res.innerHTML += '<div class="empty">æ²¡æœ‰ç»“æœ</div>';
      }
      for(const item of list){
        const hex = toHex(item.unicode);
        const glyphChar = (item.char && item.char.length===1) ? item.char : charFromHex(hex);
        const card = document.createElement('div');
        card.className = 'card';
        card.innerHTML = `
          <div class="thumb"></div>
          <div class="code-line">
            <div class="char">${glyphChar||'?'}<span class="muted sm">${item.unicode||''}</span></div>
            <button class="btn btn-ghost sm" title="å¤åˆ¶ Unicode" data-copy="${item.unicode||''}">å¤åˆ¶</button>
          </div>
          <div class="muted sm">ç›¸ä¼¼åº¦ï¼š${toSimPercent(item.distance)} <span class="sep">Â·</span> è·ç¦»ï¼š${typeof item.distance==='number'? item.distance.toFixed(4): ''}</div>
        `;
        $res.appendChild(card);
        const t = card.querySelector('.thumb');
        if(glyphDetector.canRender(glyphChar)){
          t.innerHTML = `<div class="glyph" aria-hidden="true">${glyphChar||'?'}</div>`;
        }else{
          const url = imgUrlFromHex(hex);
          t.innerHTML = `<img src="${url}" alt="${glyphChar||'?'}" />`;
          const codeLine = card.querySelector('.code-line');
          codeLine.insertAdjacentHTML('beforeend', `<span class="badge warn" title="æµè§ˆå™¨æ— æ³•æ¸²æŸ“ï¼Œä½¿ç”¨æœåŠ¡ç«¯SVG">æœåŠ¡ç«¯æ¸²æŸ“</span>`);
          usedServerSVG = true;
        }
      }
      // Show a notice if any glyphs required server-side rendering
      if(usedServerSVG){
        $status.textContent = 'éƒ¨åˆ†å­—ç¬¦ä½¿ç”¨æœåŠ¡ç«¯æ¸²æŸ“';
        $status.classList.remove('err');
      } else {
        $status.textContent = '';
      }
      $res.querySelectorAll('[data-copy]').forEach(btn=>{
        btn.addEventListener('click', ()=> copy(btn.getAttribute('data-copy')));
      });
      // Reveal results panel and move search bar to top like Google
      document.body.classList.add('has-results');
      document.getElementById('resultsPanel').hidden = false;
    }

    async function callApiChar(ch, topk){
      const body = JSON.stringify({ char: ch, top_k: Number(topk)||12 });
      const r = await fetch('/search/char', { method:'POST', headers:{'Content-Type':'application/json'}, body });
      if(!r.ok) throw new Error(await r.text());
      return r.json();
    }
    async function callApiUnicode(hex, topk){
      const body = JSON.stringify({ unicode: hex, top_k: Number(topk)||12 });
      const r = await fetch('/search/unicode', { method:'POST', headers:{'Content-Type':'application/json'}, body });
      if(!r.ok) throw new Error(await r.text());
      return r.json();
    }

    $form.addEventListener('submit', async (e)=>{
      e.preventDefault();
      const q = $q.value.trim();
      const topk = $k.value;
      $status.classList.remove('err');
      $status.textContent = 'æŸ¥è¯¢ä¸­â€¦';
      $res.classList.add('loading');
      try{
        let resp;
        const upper = q.toUpperCase();
        let qHexForUI = null;
        if(/^U\+[0-9A-F]+$/.test(upper) || /^[0-9A-F]+$/.test(upper)){
          const hex = upper.replace(/^U\+/, '');
          qHexForUI = hex;
          resp = await callApiUnicode(hex, topk);
        }else if(q.length===1){
          qHexForUI = q.codePointAt(0).toString(16).toUpperCase().padStart(4,'0');
          resp = await callApiChar(q, topk);
        }else{
          throw new Error('è¯·è¾“å…¥å•ä¸ªæ±‰å­—æˆ– Unicode');
        }
        render(resp.results||[], resp.query||q, qHexForUI);
        $status.textContent = '';
      }catch(err){
        console.error(err);
        $res.innerHTML = `<div class=\"empty\">è¯·æ±‚å¤±è´¥ï¼š${String(err)}</div>`;
        $status.textContent = 'è¯·æ±‚å¤±è´¥';
        $status.classList.add('err');
        document.body.classList.add('has-results');
        document.getElementById('resultsPanel').hidden = false;
      }finally{
        $res.classList.remove('loading');
      }
    });
  </script>
</body>
</html>
